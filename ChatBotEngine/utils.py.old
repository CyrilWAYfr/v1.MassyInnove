######## TOUTES LES FONCTIONS POUR ENVOYER LES INSTRUCTIONS A l'IA ET POUR INTERPRETER SES REPONSES


############ STRUCTURE DE REPONSE ATTENDUE

def _build_agent_directive(agent_content: str) -> str:
    base = """
{{AGENT_BLOCK}}

---

Tu es un assistant IA qui doit toujours r√©pondre dans un **JSON strictement valide** (aucun texte en dehors du JSON).

### Structure JSON attendue
Ta r√©ponse compl√®te doit suivre exactement cette structure :

{
  "main_markdown": "Texte principal en Markdown...",
  "files": [
    {
      "filename": "nom_du_fichier.extension",
      "type": "txt|xlsx|docx|autre_√†_venir",
      "description": "Description br√®ve",
      "content": "Contenu ou structure JSON selon type"
    }
  ]
}

---

### Sp√©cifications du champ content par type de fichier

#### 1. Type `txt`
- Cha√Æne de texte brut
- Peut contenir "\\n"


#### 2. Type `xlsx`

Le champ `content` doit √™tre un **objet JSON strictement structur√©**, con√ßu pour √™tre converti en fichier Excel avec la biblioth√®que Python **openpyxl**.  
Tu dois donc respecter strictement les capacit√©s r√©elles d‚Äôopenpyxl, sans utiliser de formats complexes ou avanc√©s.

Le JSON doit suivre exactement cette structure :

{
  "sheets": [
    {
      "name": "Nom_de_la_feuille",
      "rows": [
        [
          // Chaque cellule peut √™tre :
          // 1) une valeur simple (texte ou nombre)
          // 2) un objet d√©crivant la valeur + un formatage simple compatible openpyxl
          "Texte simple",
          123,
          {
            "value": "Texte",
            "bold": true,
            "italic": true,
            "font_size": 14,
            "align": "center"
          }
        ],
        ...
      ],
      "column_widths": [ 25, 40, 15 ]   // (optionnel) Largeur des colonnes
    }
  ]
}

### Formatage autoris√© (et uniquement celui-ci)

Pour les cellules d√©crites comme objets :

- **value** (obligatoire) : texte ou nombre
- **bold** : true | false
- **italic** : true | false
- **font_size** : nombre (ex. 12, 14, 18)
- **align** : "left" | "center" | "right"

Ces propri√©t√©s correspondent **exactement** aux options r√©ellement support√©es par `openpyxl` dans cette application.

### Restrictions strictes (IMPORTANTES)

Comme le fichier est g√©n√©r√© avec *openpyxl* :

- ‚ùå Pas de couleurs (background, texte, bordures)
- ‚ùå Pas de bordures
- ‚ùå Pas de fusion de cellules
- ‚ùå Pas de formules
- ‚ùå Pas de styles complexes
- ‚ùå Pas de mises en forme conditionnelles
- ‚ùå Pas de types de donn√©es avanc√©s

Tu dois rester dans les limites du formattage basique de `openpyxl`.

### Exemple valide

{
  "sheets": [
    {
      "name": "Po√®me",
      "rows": [
        [
          { "value": "Demain, d√®s l‚Äôaube...", "bold": true, "align": "center", "font_size": 16 }
        ],
        [
          { "value": "Victor Hugo (1802-1885)", "italic": true, "align": "center", "font_size": 12 }
        ],
        [],
        [
          { "value": "Demain, d√®s l'aube, √† l'heure o√π blanchit la campagne,", "italic": true }
        ],
        [
          { "value": "Je partirai. Vois-tu, je sais que tu m'attends.", "italic": true }
        ]
      ],
      "column_widths": [ 60 ]
    }
  ]
}


#### 3. Type `docx`
- **Tu dois renvoyer un objet JSON STRICT**, jamais du RTF.

Structure obligatoire :

{
  "title": {
    "text": "Titre",
    "bold": true,
    "align": "center",
    "size": 20
  },
  "paragraphs": [
    {
      "text": "Texte",
      "italic": true,
      "align": "center",
      "size": 12
    }
  ]
}

R√®gles imp√©ratives :
- ‚ùå JAMAIS de RTF (`{\\rtf1 ...}`)
- ‚ùå JAMAIS de HTML ou Markdown dans `content`
- ‚úî JSON strict uniquement

---

### Consignes g√©n√©rales
- Toujours renvoyer un JSON unique.
- Aucune sortie avant ou apr√®s le JSON.
- Toujours des guillemets doubles.
"""

    return base.replace("{{AGENT_BLOCK}}", agent_content.strip())


#################   EXTRACTION DU TEXTE DE REPONSE PRINCIPALE



def extract_markdown_from_agent_response(raw_response: str) -> str:
    if not isinstance(raw_response, str):
        return ""

    match = re.search(r"```(?:json)?\s*([\s\S]*?)\s*```", raw_response, flags=re.IGNORECASE)
    candidate = match.group(1).strip() if match else raw_response.strip()

    try:
        data = json.loads(candidate)
        if isinstance(data, dict) and "main_markdown" in data:
            return data["main_markdown"].strip()
    except Exception:
        try:
            inner_match = re.search(r'"main_markdown"\s*:\s*"([^"]+)"', candidate)
            if inner_match:
                return inner_match.group(1).strip()  # ‚úÖ plus d'encodage/d√©codage
        except Exception:
            pass

    return candidate.strip()


##############   GENERATION DU TXT DE DEBUG DECRIVANT LA STRUCTURE DE LA REPONSE :

def describe_agent_json_structure(raw_text: str) -> str:
    """
    Identifie de mani√®re purement textuelle si la r√©ponse contient un bloc JSON
    avec du markdown et/ou des fichiers.
    """
    if not raw_text or not raw_text.strip():
        return "‚ö™ Structure IA : vide"

    text = raw_text.strip()

    # Juste d√©tection basique, rien de plus
    if '"main_markdown"' in text and '"files"' in text:
        # V√©rifie si la liste de fichiers est vide
        if '"files": []' in text or '"files": []' in text.replace(" ", ""):
            return "üü¢ R√©ponse Markdown seule"
        else:
            # Essaye d'identifier les types connus
            types = []
            for t in re.findall(r'"type"\s*:\s*"([^"]+)"', text):
                t_low = t.lower()
                if t_low == "txt":
                    types.append("fichier texte")
                elif t_low == "xlsx":
                    types.append("fichier Excel")
                else:
                    types.append(f"fichier {t}")
            if types:
                return f"üü¢ Markdown + {' + '.join(types)}"
            else:
                return "üü¢ Markdown + fichiers (type ind√©termin√©)"
    elif '"main_markdown"' in text:
        return "üü¢ R√©ponse Markdown seule"
    else:
        return "üü¢ R√©ponse texte libre / Markdown direct"


####################   TRAITEMENT DES FICHIERS RE√ßUS

import json, re
from pathlib import Path
from django.conf import settings
from openpyxl import Workbook


# FONCTION UTILITAIRE POUR TENIR COMPTE DES VARIATIONS DANS LE FORMAT DE LA REPONSE

import json

def _extract_json_candidate(raw: str) -> str:
    """
    Extraction tr√®s robuste :
    - d√©tecte le bloc { ... } le plus long
    - ignore tout ce qui vient avant / apr√®s
    - beau fonctionnement m√™me si des tool_file ont √©t√© ins√©r√©s
    """

    if not isinstance(raw, str):
        return ""

    s = raw.strip()

    # 1) R√©cup√®re tous les blocs {...}
    matches = re.findall(r"\{[\s\S]*?\}", s)

    if not matches:
        return s

    # 2) Prend le bloc JSON le plus long => en g√©n√©ral le bon
    candidate = max(matches, key=len).strip()

    return candidate




# TRAITEMENT SEQUENTIEL DE TOUS LES FICHIERS

def extract_files_from_agent_response(raw_response: str, request=None) -> list[dict]:
    """
    Extrait les fichiers depuis la r√©ponse JSON structur√©e de l‚Äôagent.
    G√®re .txt et .xlsx. Version robuste SANS 'unicode_escape'.
    """
    try:
        candidate = _extract_json_candidate(raw_response)
        data = json.loads(candidate)
    except Exception:
        return []

    if not isinstance(data, dict) or "files" not in data:
        return []

    export_dir = Path(settings.MEDIA_ROOT) / "chat_exports"
    export_dir.mkdir(parents=True, exist_ok=True)

    out = []
    for f in data.get("files") or []:
        if not isinstance(f, dict):
            continue

        filename     = f.get("filename") or "fichier.txt"
        ftype        = (f.get("type") or "txt").lower()
        description  = f.get("description") or ""
        content      = f.get("content")

        try:
            if ftype == "txt" and isinstance(content, str):
                path = _generate_txt_file(filename, content, export_dir)
            elif ftype == "xlsx" and isinstance(content, dict):
                path = _generate_xlsx_file(filename, content, export_dir)
            elif ftype == "docx" and isinstance(content, (str, dict)):
                path = _generate_docx_file(filename, content, export_dir)
            else:
                continue  # types non g√©r√©s (√† √©tendre plus tard)

            url = request.build_absolute_uri(
                settings.MEDIA_URL + f"chat_exports/{path.name}"
            ) if request else None

            out.append({
                "filename": filename,
                "description": description,
                "url": url,
                "type": ftype,
            })
        except Exception as e:
            logger.error(f"Erreur g√©n√©ration fichier {filename} ({ftype}): {e}")
            continue


    return out

# GENERATION TXT

def _generate_txt_file(filename: str, content: str, export_dir: Path) -> Path:
    safe_name = re.sub(r"[^a-zA-Z0-9_\-.]", "_", filename)
    p = export_dir / safe_name
    p.write_text(content or "", encoding="utf-8")
    return p

from openpyxl import Workbook
from openpyxl.styles import Font, Alignment
from pathlib import Path
import re

def _generate_xlsx_file(filename: str, content: dict, export_dir: Path) -> Path:
    """
    G√©n√®re un fichier XLSX √† partir d'une structure JSON enrichie :
    {
      "sheets": [
        {
          "name": "Po√®me",
          "rows": [
            [
              { "value": "...", "bold": true, "font_size": 16, "font": "Arial", "align": "center" }
            ],
            [],
            [
              { "value": "...", "italic": true }
            ]
          ],
          "column_widths": [60]
        }
      ]
    }
    """

    safe_name = re.sub(r"[^a-zA-Z0-9_\-.]", "_", filename)
    path = export_dir / safe_name

    wb = Workbook()
    wb.remove(wb.active)  # on supprime la feuille par d√©faut

    for sheet in content.get("sheets", []):
        name = sheet.get("name", "Feuille1")
        rows = sheet.get("rows", [])
        widths = sheet.get("column_widths", [])

        ws = wb.create_sheet(title=name)

        # -- Largeurs de colonnes --
        for idx, w in enumerate(widths, start=1):
            try:
                ws.column_dimensions[chr(64 + idx)].width = w
            except Exception:
                pass

        # -- Contenu cellule par cellule --
        for row in rows:
            # ligne vide
            if row == []:
                ws.append([""])
                continue

            excel_row = []
            style_specs = []

            for cell in row:
                if isinstance(cell, dict) and "value" in cell:
                    value = cell.get("value", "")
                    excel_row.append(value)
                    style_specs.append(cell)
                else:
                    # cellule simple ("texte brut")
                    excel_row.append(cell)
                    style_specs.append(None)

            # append row ‚Üí openpyxl cr√©e les cellules
            ws.append(excel_row)

            # r√©cup√®re l'index de la derni√®re ligne √©crite
            row_idx = ws.max_row

            # appliquer formatages
            for col_idx, spec in enumerate(style_specs, start=1):
                if not isinstance(spec, dict):
                    continue

                cell = ws.cell(row=row_idx, column=col_idx)

                # Font
                font_kwargs = {}
                if spec.get("bold"):
                    font_kwargs["bold"] = True
                if spec.get("italic"):
                    font_kwargs["italic"] = True
                if "font_size" in spec:
                    try:
                        font_kwargs["size"] = float(spec["font_size"])
                    except:
                        pass
                if "font" in spec:
                    font_kwargs["name"] = spec["font"]

                cell.font = Font(**font_kwargs)

                # Alignement
                align = spec.get("align", "").lower()
                if align in ("center", "right", "left"):
                    cell.alignment = Alignment(horizontal=align)

    wb.save(path)
    return path


#GENERATION DOC

from docx import Document
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.shared import Pt

def _generate_docx_file(filename: str, content, export_dir: Path) -> Path:
    """
    G√©n√®re un fichier DOCX √† partir :
    - soit d‚Äôune cha√Æne simple (texte brut)
    - soit d‚Äôun dict structur√© contenant {title:{...}, paragraphs:[...]}
    """

    safe_name = re.sub(r"[^a-zA-Z0-9_\-.]", "_", filename)
    p = export_dir / safe_name

    doc = Document()

    # ---------- CAS 1 : texte brut ----------
    if isinstance(content, str):
        for line in content.split("\n"):
            doc.add_paragraph(line)
        doc.save(p)
        return p

    # ---------- CAS 2 : contenu structur√© ----------
    if isinstance(content, dict):

        # Helper: normalisation align
        def parse_align(v):
            if not isinstance(v, str):
                return WD_ALIGN_PARAGRAPH.LEFT
            v = v.lower()
            return {
                "center": WD_ALIGN_PARAGRAPH.CENTER,
                "right": WD_ALIGN_PARAGRAPH.RIGHT,
                "justify": WD_ALIGN_PARAGRAPH.JUSTIFY
            }.get(v, WD_ALIGN_PARAGRAPH.LEFT)

        # Helper: ajout d‚Äôun paragraphe format√©
        def add_paragraph(block):
            text = block.get("text", "")
            para = doc.add_paragraph()
            run = para.add_run(text)

            # Bold / Italic
            if block.get("bold"):
                run.bold = True
            if block.get("italic"):
                run.italic = True

            # Taille
            if isinstance(block.get("size"), (int, float)):
                run.font.size = Pt(block["size"])

            # Police
            if isinstance(block.get("font"), str):
                run.font.name = block["font"]

            # Alignement
            para.alignment = parse_align(block.get("align"))

            # Interligne
            if block.get("line_spacing"):
                try:
                    para.paragraph_format.line_spacing = float(block["line_spacing"])
                except:
                    pass

        # ----- Titre -----
        title = content.get("title")
        if isinstance(title, dict):
            add_paragraph(title)

        # ----- Paragraphes -----
        for block in content.get("paragraphs", []):
            if isinstance(block, dict):
                add_paragraph(block)

        doc.save(p)
        return p

    # Aucun format reconnu
    raise ValueError("Format DOCX non reconnu")


