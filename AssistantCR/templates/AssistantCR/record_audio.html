{% load static %}
<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>D√©mo Voxtral ‚Äî Capture & Transcription</title>
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        padding: 2rem;
        background: #f5f5f5;
      }
      main {
        max-width: 32rem;
        margin: auto;
        background: white;
        padding: 2rem;
        border-radius: 1rem;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
      }
      button {
        width: 100%;
        padding: 1rem;
        font-size: 1.1rem;
        font-weight: 600;
        border: none;
        border-radius: 0.75rem;
        cursor: pointer;
        transition: transform 0.1s ease;
      }
      button:active { transform: scale(0.98); }
      #recordBtn { background: #2563eb; color: white; }
      #stopBtn { background: #ef4444; color: white; display: none; }
      #status { margin-top: 1rem; min-height: 1.5rem; color: #6b7280; }
      #transcript { margin-top: 1.5rem; white-space: pre-wrap; }
      pre#rawJson { background: #0f172a; color: #f8fafc; padding: 1rem; border-radius: 0.75rem; overflow-x: auto; }
    </style>
  </head>
  <body>
    <main>
      <h1>Transcription audio avec Voxtral</h1>
      <p>
        Appuyez sur ¬´ Enregistrer ¬ª pour commencer √† capturer votre voix, puis
        ¬´ Arr√™ter &amp; transcrire ¬ª pour envoyer l'audio √† votre serveur Django.
      </p>

      <button id="recordBtn">üéôÔ∏è Enregistrer</button>
      <button id="stopBtn">‚ñ† Arr√™ter &amp; transcrire</button>

      <p id="status" aria-live="polite"></p>

      <section id="transcript" aria-live="polite" aria-label="Transcription"></section>

      <h2>R√©ponse Voxtral (brute)</h2>
      <pre id="rawJson" aria-live="polite"></pre>
    </main>

    <script>
      const recordBtn   = document.getElementById("recordBtn");
      const stopBtn     = document.getElementById("stopBtn");
      const statusEl    = document.getElementById("status");
      const transcriptEl= document.getElementById("transcript");
      const rawJsonEl   = document.getElementById("rawJson");

      const TRANSCRIBE_URL = "{% url 'assistantcr:transcribe_audio' %}";

      let mediaRecorder;
      let chunks = [];

      recordBtn.addEventListener("click", startRecording);
      stopBtn.addEventListener("click", stopRecording);

      async function startRecording() {
        transcriptEl.textContent = "";
        rawJsonEl.textContent = "";
        statusEl.textContent = "Initialisation du micro‚Ä¶";

        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

          // Choix MIME le plus compatible (Safari iOS peut pr√©f√©rer mp4/m4a)
          const mimeType = MediaRecorder.isTypeSupported("audio/mp4")
            ? "audio/mp4"
            : (MediaRecorder.isTypeSupported("audio/webm;codecs=opus")
                ? "audio/webm;codecs=opus"
                : "audio/webm");

          mediaRecorder = new MediaRecorder(stream, { mimeType });
          chunks = [];

          mediaRecorder.addEventListener("dataavailable", (event) => {
            if (event.data && event.data.size > 0) {
              chunks.push(event.data);
            }
          });

          mediaRecorder.addEventListener("stop", sendRecording);

          mediaRecorder.start();
          statusEl.textContent = "Enregistrement en cours‚Ä¶";
          recordBtn.style.display = "none";
          stopBtn.style.display   = "block";
        } catch (error) {
          console.error(error);
          statusEl.textContent = "Impossible d'acc√©der au micro. V√©rifiez les permissions du navigateur.";
        }
      }

      async function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
          statusEl.textContent = "Arr√™t de l'enregistrement‚Ä¶";
          mediaRecorder.stop();
        }
      }

      async function sendRecording() {
        statusEl.textContent = "Pr√©paration & envoi de l'audio‚Ä¶";

        try {
          const mime = mediaRecorder?.mimeType || "audio/webm";
          const isMp4  = mime.includes("mp4");
          const isWebm = mime.includes("webm");

          // 1) Force un MIME audio (√©vite que √ßa parte en video/webm)
          const uploadMime = isMp4 ? "audio/mp4" : (isWebm ? "audio/webm" : mime);

          // 2) Donne une EXTENSION audio claire :
          //    - mp4 -> .m4a
          //    - webm -> .weba  (tr√®s important: .webm est souvent mapp√© en video/webm c√¥t√© serveurs)
          const ext = isMp4 ? "m4a" : (isWebm ? "weba" : "wav");

          const blob = new Blob(chunks, { type: uploadMime });
          const formData = new FormData();
          formData.append("audio", blob, `voxtral-${Date.now()}.${ext}`);


          const response = await fetch(TRANSCRIBE_URL, {
            method: "POST",
            body: formData,
            headers: {
              "X-CSRFToken": getCookie("csrftoken"),
              "Accept": "application/json",
            },
            credentials: "same-origin",
          });

          // Lecture robuste des erreurs (HTML/texte vs JSON)
          if (!response.ok) {
            const text = await response.text();
            try {
              const err = JSON.parse(text);
              throw new Error(err.error || JSON.stringify(err));
            } catch (_) {
              throw new Error(`HTTP ${response.status}: ${text.slice(0, 400)}`);
            }
          }

          const data = await response.json();

          transcriptEl.textContent = data.text || "Transcription vide";
          rawJsonEl.textContent = JSON.stringify(
            data.raw || {
              model: "voxtral-mini-2507",
              text: "",
              language: "",
              segments: [],
              usage: {
                prompt_audio_seconds: 0,
                prompt_tokens: 0,
                total_tokens: 0,
                completion_tokens: 0,
              },
            },
            null,
            2
          );
          statusEl.textContent = "Transcription termin√©e.";
        } catch (error) {
          console.error(error);
          statusEl.textContent = `Erreur: ${error.message}`;
        } finally {
          recordBtn.style.display = "block";
          stopBtn.style.display   = "none";
        }
      }

      // R√©cup√®re le cookie CSRF (Django)
      function getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(";").shift();
        return "";
      }
    </script>
  </body>
</html>
